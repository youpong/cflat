options {
  DEBUG_PARSER = true;
  UNICODE_INPUT = true;
  JDK_VERSION="11";
}

PARSER_BEGIN(Parser)
package cflat.parser;

import cflat.ast.AddressNode;
import cflat.ast.AST;
import cflat.ast.CastNode;
import cflat.ast.DereferenceNode;
import cflat.ast.ExprNode;
import cflat.ast.IntegerLiteralNode;
import cflat.ast.Location;
import cflat.ast.PrefixOpNode;
import cflat.ast.SizeofExprNode;
import cflat.ast.SizeofTypeNode;
import cflat.ast.StringLiteralNode;
import cflat.ast.TypeNode;
import cflat.ast.UnaryOpNode;
import cflat.ast.VariableNode;
import cflat.exception.FileException;
import cflat.exception.SyntaxException;
import cflat.type.IntegerTypeRef;
import cflat.type.PointerTypeRef;
import cflat.type.TypeRef;
import cflat.utils.ErrorHandler;
import java.io.*;
import java.util.*;

/**
 * parser
 */
public class Parser {

  static public AST parseFile(File file, LibraryLoader loader,
                              ErrorHandler errorHandler)
			      throws SyntaxException, FileException {
    return parseFile(file, loader, errorHandler, false);
  }

  static public AST parseFile(File file, LibraryLoader loader,
                              ErrorHandler errorHandler, boolean debug)
			      throws SyntaxException, FileException {
    return newFileParser(file, loader, errorHandler, debug).parse();
  }

  static final public String SOURCE_ENCODING = "UTF-8";
  
  static public Parser newFileParser(File file, LibraryLoader loader,
                                     ErrorHandler errorHandler, boolean debug)
				     throws FileException {
    try {
      BufferedReader r =
        new BufferedReader(
	  new InputStreamReader(new FileInputStream(file), SOURCE_ENCODING));
      return new Parser(r, file.getPath(), loader, errorHandler, debug);
    }
    catch (FileNotFoundException ex) {
      throw new FileException(ex.getMessage());
    }
    catch (UnsupportedEncodingException ex) {
      throw new Error(SOURCE_ENCODING + " is not supported??: " +
                      ex.getMessage());
    }
  }  

  public Parser(Reader s, String name, LibraryLoader loader,
                ErrorHandler errorHandler) {
    this(s, name, loader, errorHandler, false);		
  }
  
  private String sourceName;
  private LibraryLoader loader;
  private ErrorHandler errorHandler;
  private Set<String>knownTypedefs;
  
  public Parser(Reader s, String name, LibraryLoader loader,
                ErrorHandler errorHandler, boolean debug) {
    this(s);
    this.sourceName = name;
    this.loader = loader;
    this.errorHandler = errorHandler;
    this.knownTypedefs = new HashSet<String>();
    if(debug) {
      enable_tracing();
    } else {
      disable_tracing();
    }
  }

  public AST parse() throws SyntaxException {
    try {
      return compilation_unit();
    }
    catch (TokenMgrException ex) {
      throw new SyntaxException(ex.getMessage());
    }  
    catch (ParseException ex) {
      throw new SyntaxException(ex.getMessage());
    }
    catch (LookaheadSuccess err) {
      throw new SyntaxException("syntax error");
    }
  }  

  // TODO: test
  private void addType(String name) {
    knownTypedefs.add(name);
  }
  
  // TODO: test
  private boolean isType(String name) {
    return knownTypedefs.contains(name);
  }

  // TODO: test
  private IntegerLiteralNode integerNode(Location loc, String image) {
    long i = integerValue(image);
    if (image.endsWith("UL")) {
      return new IntegerLiteralNode(loc, IntegerTypeRef.ulongRef(), i);
    }
    else if(image.endsWith("L")) {
      return new IntegerLiteralNode(loc, IntegerTypeRef.longRef(), i);
    }
    else if(image.endsWith("U")) {
      return new IntegerLiteralNode(loc, IntegerTypeRef.uintRef(), i);
    }
    else {
      return new IntegerLiteralNode(loc, IntegerTypeRef.intRef(), i);
    }
  }

  // TODO: test
  private long integerValue(String image) {
    String s = image.replaceFirst("[UL]+", "");
    if (s.startsWith("0x") || s.startsWith("0X")) {
      return Long.parseLong(s.substring(2), 16);
    }
    else if(s.startsWith("0") && !s.equals("0")) {
      return Long.parseLong(s.substring(1), 8);
    }
    return Long.parseLong(s, 10);
  }

  // TODO: test
  private long characterCode(String image) throws ParseException {
    String s = stringValue(image);
    if (s.length() != 1) {
      throw new Error("must not happen: character length > 1");
    }
    return (long)s.charAt(0);
  }

  // TODO: test
  private String stringValue(String _image) throws ParseException {
    int pos = 0;
    int idx;
    StringBuffer buf = new StringBuffer();
    String image = _image.substring(1, _image.length() - 1);

    while((idx = image.indexOf("\\", pos)) >= 0) {
      buf.append(image.substring(pos, idx));
      if(image.length() >= idx + 4
             && Character.isDigit(image.charAt(idx+1))
             && Character.isDigit(image.charAt(idx+2))
             && Character.isDigit(image.charAt(idx+3))){
         buf.append(unescapeOctal(image.substring(idx+1, idx+4)));
         pos = idx + 4;
      }
      else {
         buf.append(unescapeSeq(image.charAt(idx+1)));
         pos = idx + 2;
      }
    }   
    if(pos < image.length()) {
        buf.append(image.substring(pos, image.length()));
    }
    return buf.toString();		       
  }

  // TODO: test
  private TypeRef size_t() {
    return IntegerTypeRef.ulongRef();
  }

  private static final int charMax = 255;
  // TODO: test
  private char unescapeOctal(String digits) throws ParseException {
    int i = Integer.parseInt(digits, 8);
    if (i > charMax) {
      throw new ParseException("octal character sequence too big: \\" + digits);
    }
    return (char)i;
  }

  private static final char bell = 7;
  private static final char backspace = 8;
  private static final char escape = 27;
  private static final char vt = 11;

  // TODO: test
  private char unescapeSeq(char c) throws ParseException {
    switch(c) {
    case '0': return '\0';
    case '"': return '"';
    case '\'': return '\'';
    case 'a': return bell;
    case 'b': return backspace;
    case 'e': return escape;
    case 'f': return '\f';
    case 'n': return '\n';
    case 'r': return '\r';
    case 't': return '\t';
    case 'v': return vt;
    default:
      throw new ParseException("unknown escape sequence: \"\\" + c);
    }  
  }
  
  static public void parse(Reader reader) throws ParseException {
    new Parser(reader).compilation_unit();
  }

  protected Location location(Token t) {
    return new Location(sourceName, t);
  }
}
PARSER_END(Parser)

SPECIAL_TOKEN: { <SPACES: ([" ","\t","\r","\n","\f"])+> }

SPECIAL_TOKEN: { <LINE_COMMENT: "//" (~["\n","\r"])*("\n"|"\r\n"|"\r")?> }

MORE: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMENT: "*/"> : DEFAULT }

MORE: { <"\""> : IN_STRING }
<IN_STRING> MORE: {
    <(~["\"","\\","\n","\r"])+>
  | <"\\"(["0"-"7"]){3}>
  | <"\\"~[]>
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }

MORE: { <"'"> : IN_CHARACTER }
<IN_CHARACTER> MORE: {
    <~["'","\\","\n","\r"]> : CHARACTER_TERM
  | <"\\"(["0"-"7"]){3}>    : CHARACTER_TERM
  | <"\\"~[]>               : CHARACTER_TERM
}
<CHARACTER_TERM> TOKEN: { <CHARACTER: "'"> : DEFAULT }

TOKEN: {
    <BREAK    : "break"   >
  | <CASE     : "case"    >
  | <CHAR     : "char"    >
  | <CONST    : "const"   >
  | <CONTINUE : "continue">
  | <DEFAULT_ : "default" >
  | <DO       : "do"      >
  | <ELSE     : "else"    >
  | <FOR      : "for"     >
  | <GOTO     : "goto"    >
  | <IF       : "if"      >
  | <INT      : "int"     >
  | <IMPORT   : "import"  >
  | <LONG     : "long"    >
  | <RETURN   : "return"  >
  | <SHORT    : "short"   >
  | <SIZEOF   : "sizeof"  >
  | <STATIC   : "static"  >
  | <STRUCT   : "struct"  >
  | <SWITCH   : "switch"  >
  | <TYPEDEF  : "typedef" >
  | <UNION    : "union"   >
  | <UNSIGNED : "unsigned">
  | <VOID     : "void"    >
  | <WHILE    : "while"   >
}

TOKEN: {
    <INTEGER: ["1"-"9"](["0"-"9"])*("U")?("L")?
            | "0"["x","X"](["0"-"9","a"-"f","A"-"F"])+("U")?("L")?
	    | "0"(["0"-"7"])*("U")?("L")?
            >
}

TOKEN: {
    <IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}

AST compilation_unit(): {}
{
  import_stmts() top_defs() <EOF>
    {
      // TODO
      return null;
    }  
}

void import_stmts() : {}
{
  (import_stmt())*		
}

void import_stmt() : {}
{
  <IMPORT> name() ("." name())* ";"
}

void top_defs() : {}
{
  ( LOOKAHEAD(storage() typeref() <IDENTIFIER> "(")
    defun()
  | LOOKAHEAD(3)
    defvars()
  | defconst()
  | defstruct()
  | defunion()
  | typedef()
  )*
}

void defun() : {}
{
  storage() typeref() name() "(" params() ")" block()
}

void params() : {}
{
  LOOKAHEAD(<VOID> ")")
  <VOID>
  | fixedparams() ["," "..."]
}

void fixedparams() : {}
{
  param() (LOOKAHEAD(2) "," param())*
}

void param() : {}
{
  type() name()
}

void block() : {}
{
  "{" defvar_list() stmts() "}"
}

void defvars() : {}
{
  storage() type() name() ["=" expr()]
              ("," name() ["=" expr()])* ";"
}
void storage() : {}
{
  [<STATIC>]
}

void defconst(): {}
{
  <CONST> type() name() "=" expr() ";"
}

void defstruct(): {}
{
  <STRUCT> name() member_list() ";"
}

void defunion(): {}
{
  <UNION> name() member_list() ";"
}

void typedef(): {}
{
  <TYPEDEF> typeref() <IDENTIFIER> ";"
}

void name() : {}
{
  <IDENTIFIER>
}

// TODO: implement
TypeNode type() : {}
{
  typeref()
    {
      return null;
    }  
}

void typeref() : {}
{
  typeref_base()
  ( LOOKAHEAD(2) "[" "]"
  | "[" <INTEGER> "]"
  | "*"
  | "(" param_typerefs() ")"
  )*
}

void typeref_base() : {}
{
  <VOID>
  | <CHAR>
  | <SHORT>
  | <INT>
  | <LONG>
  | LOOKAHEAD(2) <UNSIGNED> <CHAR>
  | LOOKAHEAD(2) <UNSIGNED> <SHORT>
  | LOOKAHEAD(2) <UNSIGNED> <INT>
  | <UNSIGNED> <LONG>
  | <STRUCT> <IDENTIFIER>
  | <UNION> <IDENTIFIER>
  | LOOKAHEAD({isType(getToken(1).image)}) <IDENTIFIER>
}

void param_typerefs() : {}
{
  LOOKAHEAD(<VOID> ")")
  <VOID>
  | fixedparam_typerefs() [ "," "..." ]
}

void fixedparam_typerefs() : {}
{
  typeref() ( LOOKAHEAD(2) "," typeref() )*
}

void defvar_list() : {}
{
  (defvars())*
}

void stmts() : {}
{
  (stmt())*
}

void stmt() : {}
{
  (";"
  | LOOKAHEAD(2) labeled_stmt()
  | expr() ";"
  | block()
  | if_stmt()
  | while_stmt()
  | dowhile_stmt()
  | for_stmt()
  | switch_stmt()
  | break_stmt()
  | continue_stmt()
  | goto_stmt()
  | return_stmt()
  )
}

void labeled_stmt() : {}
{
  <IDENTIFIER> ":" stmt()
}

void if_stmt() : {}
{
  <IF> "(" expr() ")" stmt() [LOOKAHEAD(1) <ELSE> stmt()]
}

void while_stmt() : {}
{
  <WHILE> "(" expr() ")" stmt()
}

void dowhile_stmt() : {}
{
  <DO> stmt() <WHILE> "(" expr() ")" ";"
}

void for_stmt() : {}
{
  <FOR> "(" [expr()] ";" [expr()] ";" [expr()] ")" stmt()
}

void switch_stmt() : {}
{
  <SWITCH> "(" expr() ")" "{" case_clauses() "}"
}

void case_clauses() : {}
{
  (case_clause())*
  [default_clause()]
}

void case_clause() : {}
{
  cases() case_body()
}

void cases() : {}
{
  (<CASE> primary() ":")+
}

void default_clause() : {}
{
  <DEFAULT_> ":" case_body()
}

void case_body() : {}
{
  (stmt())+
}

void break_stmt() : {}
{
  <BREAK> ";"
}

void continue_stmt() : {}
{
  <CONTINUE> ";"
}

void return_stmt() : {}
{
  LOOKAHEAD(2) <RETURN> ";"
  | <RETURN> expr() ";"
}  

void goto_stmt() : {}
{
  <GOTO> <IDENTIFIER> ";"
}

void member_list() : {}
{
  "{" (slot() ";")* "}"
}

void slot() : {}
{
  type() name()
}

// TODO: implement
ExprNode expr() : {}
{
  (LOOKAHEAD(term() "=")
  term() "=" expr()
  | LOOKAHEAD(term() opassign_op())
  term() opassign_op() expr()
  | expr10()
  ) {
      return null;
    }  
}

void opassign_op() : {}
{
  ( "+="
  | "-="
  | "*="
  | "/="
  | "%="
  | "&="
  | "|="
  | "^="
  | "<<="
  | ">>="
  )
}

void expr10() : {}
{
  expr9() [ "?" expr() ":" expr10()]
}

void expr9() : {}
{
  expr8() ("||" expr8())*
}

void expr8() : {}
{
  expr7() ("&&" expr7())*
}

void expr7() : {}
{
  expr6() ( ">" expr6()
          | "<" expr6()
          | ">=" expr6()
          | "<=" expr6()
          | "==" expr6()
          | "!=" expr6())*
}

void expr6() : {}
{
  expr5() ("|" expr5())*
}
void expr5() : {}
{
  expr4() ("^" expr4())*
}

void expr4() : {}
{
  expr3() ("&" expr3())*
}

void expr3() : {}
{
  expr2() ( ">>" expr2()
          | "<<" expr2())*
}

void expr2() : {}
{
  expr1() ( "+" expr1()
          | "-" expr1())*
}

void expr1() : {}
{
  term() ( "*" term()
         | "/" term()
	 | "%" term())* 
}

ExprNode term() :
{
  TypeNode t;
  ExprNode n;
}
{
  LOOKAHEAD("(" type())
  "(" t=type() ")" n=term() { return new CastNode(t, n); }
  | n=unary()               { return n; }
}

// TODO: implement
ExprNode unary() :
{
  ExprNode n;
  TypeNode t;
}
{
    "++" n=unary() { return new PrefixOpNode("++", n); }
  | "--" n=unary() { return new PrefixOpNode("--", n); }
  | "+"  n=unary() { return new UnaryOpNode("+", n); }
  | "-"  n=unary() { return new UnaryOpNode("-", n); }
  | "!"  n=unary() { return new UnaryOpNode("!", n); }
  | "~"  n=unary() { return new UnaryOpNode("~", n); }
  | "*"  n=unary() { return new DereferenceNode(n); }
  | "&"  n=unary() { return new AddressNode(n); }
  | LOOKAHEAD(3) <SIZEOF> "(" t=type() ")"
                   {
                     return new SizeofTypeNode(t, size_t());
		   }  
  | <SIZEOF> n=unary()
                   {
		     return new SizeofExprNode(n, size_t());
		   }
  | n=postfix()    { return n; }
}

ExprNode postfix() : {}
{
  primary() ( "++"
            | "--"
	    | "[" expr() "]"
	    | "." name()
	    | "->" name()
	    | "(" args() ")"
	    )* {
	         return null;
	       }	 
}

void args() : {}
{
  [ expr() ("," expr())* ]
}

ExprNode primary() :
{
  Token t;
  ExprNode n;
}
{
    t=<INTEGER>
    {
      return integerNode(location(t), t.image);
    }  
  | t=<CHARACTER>
    {
      return new IntegerLiteralNode(location(t),
                                    IntegerTypeRef.charRef(),
				    characterCode(t.image));
    }				    
  | t=<STRING>
    {
      return new StringLiteralNode(location(t),
                               new PointerTypeRef(IntegerTypeRef.charRef()),
	                       stringValue(t.image));
    }
  | t=<IDENTIFIER>
    {
      return new VariableNode(location(t), t.image);
    }
  | "(" n=expr() ")"
    {
      return n;
    }
}
